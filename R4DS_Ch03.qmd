---
title: "R4DS_Ch03_MyNotes"
author: "LucyT"
format: html
editor: visual
---

# R for Data Science - Chapter 03 - My notes

Re-learning R and GitHub, while trying out Quarto.

## Set-up

**Packages**

Add packages:

```{r  include=FALSE}
list.of.packages <- c("tidyverse", "arrow", "babynames", "curl", "duckdb", "gapminder", 
    "ggrepel", "ggridges", "ggthemes", "hexbin", "janitor", "Lahman", 
    "leaflet", "maps", "nycflights13", "openxlsx", "palmerpenguins", 
    "repurrrsive", "tidymodels", "writexl")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages,repos = "http://cran.us.r-project.org")

```

Load in Libraries:

```{r  include=FALSE}
#define vector of packages
new_package <- c("tidyverse", "arrow", "babynames", "curl", "duckdb", "gapminder", 
    "ggrepel", "ggridges", "ggthemes", "hexbin", "janitor", "Lahman", 
    "leaflet", "maps", "nycflights13", "openxlsx", "palmerpenguins", 
    "repurrrsive", "tidymodels", "writexl")
lapply(new_package, library, character.only=TRUE)
```

##Chapter 3: Data transformation

Using primarily the **dplyer** package, and the **nycflights13** data. To see different views of the data:

```{r}
flights
View(flights)
glimpse(flights)
```

Variable names are followed by the type of each variable:

-   <int> is short for integer,
-   <dbl> is short for double,
-   <chr> for character (aka strings), and
-   <dttm> for date-time

Functions have the following order:

1.  The first argument is the data frame.
2.  Subsequent arguments describe which columns to operate on.
3.  The output is always a new data frame.

### Rows

The most important verbs that operate on rows are:

-   *filter()*, which changes which rows are present without changing their order, and
-   *arrange()*, which changes the order of the rows without changing which are present, and
-   *distinct()*, which finds rows with unique values

Use **filter()** to find all flights that depart more than 2 hours (120 mins) late:
``` {r}
flights |>
  filter(dep_delay > 120)
```

Use other operators to filter other flights:
``` {r}
# Flights that depart on 28 Feb
jan_01 <- flights |>
  filter(month == 2 & day == 28)
glimpse(jan_01)

# Flights that depart in December or January
dec_jan <- flights |>
  filter(month == 12 | month == 1)

#Or use %in%
dec_jan <- flights |>
  filter(month %in% c(12, 1))
glimpse(dec_jan)
```

Use **arrange()** to sort flights: 
``` {r}
# Flights sorted by departure time:
flights |>
  arrange(year, month, day, dep_time)

# Flights sorted by delay time (descending):
flights |>
  arrange(desc(dep_delay))
```

Use **distinct()** to find unique data:
``` {r}
# Remove duplicate rows from data
flights |>
  distinct()

# Identify all unique origin and destination pairs
flights |>
  distinct(origin, dest)

#Repeat the above but keep the rest of the data for these pairs (will keep the first occurrence):
flights |>
  distinct(origin, dest, .keep_all = TRUE)
```

**Exercises**

1. In a single pipeline for each condition, find all flights that meet the condition:
``` {r}
# Had an arrival delay of two or more hours
flights |>
  filter(arr_delay >= 120)

# Flew to Houston (IAH or HOU)
flights |>
  filter(dest == "IAH" | dest == "HOU")

# Were operated by United, American, or Delta
flights |>
  filter(carrier %in% c("UA", "AA", "DL"))

# Departed in summer (July, August, and September)
flights |>
  filter(month %in% c(7, 8, 9))

# Arrived more than two hours late but didn’t leave late
flights |>
  filter(dep_delay <= 0 & arr_delay > 120)

# Were delayed by at least an hour, but made up over 30 minutes in flight
flights |>
  filter(dep_delay >= 60 & arr_delay <= dep_delay - 30)
```

2. Sort flights to find the flights with the longest departure delays. Find the flights that left earliest in the morning.
``` {r}
# Flights with the longest departure delays:
flights |>
  arrange(desc(dep_delay))

# Flights that left earliest in the morning:
flights |>
  arrange(dep_time)
```

3. Sort flights to find the fastest flights. 
``` {r}
# With help from solutions - use mutate to create speed variable
flights |>
  mutate(speed = distance / (air_time / 60)) |>
  arrange(desc(speed)) |>
  relocate(speed)
```

4. Was there a flight on every day of 2013?
``` {r}
flights |>
  distinct(year, month, day) |>
  nrow()
```
5. Which flights traveled the farthest distance? Which traveled the least distance?
```{r}
# Farthest distance
flights |>
  arrange(desc(distance))

# Least distance
flights |>
  arrange(distance)
```

6. Does it matter what order you used filter() and arrange() if you’re using both? Why/why not? 
**ANSWER* Yes, after filter the data are smaller so it takes less computational power to arrange.








